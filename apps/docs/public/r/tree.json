{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "tree",
  "type": "registry:component",
  "title": "Example tree",
  "author": "@gabimoncha",
  "description": "Displays a button which is always red.",
  "files": [
    {
      "path": "./node_modules/@rnr/example-library/src/components/tree/tree.tsx",
      "content": "import React, { useMemo, useRef, useState } from 'react';\nimport type { ViewStyle } from 'react-native';\nimport { FlatList, TextInput as RNInput, Text, View } from 'react-native';\nimport {\n  buildHighlightLabelConfig,\n  findAllChildrenValue,\n  findAllParentNodeByValue,\n  findNodeByValue,\n  findParentNodeByValue,\n  flattenDeepWidthChildren,\n} from './helper';\nimport TreeItem from './tree-item';\nimport { TreeMultipleMode } from './var';\nimport Empty from '../empty';\nimport { TreeOption, TreeProps, TreeSearchListData, TreeValue } from './interface';\nimport { useControllableValue, usePersistFn } from '../../hooks';\nimport { getDefaultValue } from '../../helpers';\nimport Search from '../search';\nimport { cn } from '../../lib/utils';\nimport { ArrowRightOutline } from '../icons';\n\ntype ListData = {\n  tier: number;\n} & TreeOption;\n\nconst switcherIconWrapperStyle: ViewStyle = {\n  transform: [\n    {\n      rotateZ: '90deg',\n    },\n  ],\n};\n\nconst Tree: React.FC<TreeProps> = ({\n  multiple = false,\n  multipleMode = TreeMultipleMode.NORMAL,\n  options,\n  renderSwitcherIcon,\n  indent,\n  defaultExpandedValues,\n  defaultExpandAll = false,\n  search,\n  onSearch,\n  placeholder,\n  minHeight = true,\n  cancellable = false,\n  editable = true,\n  ...restProps\n}) => {\n  const [value, onChange] = useControllableValue<TreeValue | TreeValue[] | null>(restProps, {\n    defaultValue: multiple ? [] : undefined,\n  });\n\n  const getOnSearch = usePersistFn(() => {\n    return onSearch;\n  });\n  const [expandedValues, setExpandedValues] = useState(() => {\n    if (defaultExpandAll) {\n      return findAllChildrenValue(options);\n    }\n\n    const _values: TreeValue[] = [];\n    /** 查看父节点是否要追加进去 */\n    const doPushParent = (subValue: TreeValue) => {\n      const _p = findParentNodeByValue(options, subValue);\n\n      if (_p) {\n        _values.push(_p.value);\n        doPushParent(_p.value);\n      }\n    };\n\n    defaultExpandedValues?.forEach((id) => {\n      _values.push(id);\n      doPushParent(id);\n    });\n\n    return _values;\n  });\n\n  const listData = useMemo(() => {\n    const nodes: ListData[] = [];\n\n    const findVisibleItem = (treeOption: TreeOption, tier: number) => {\n      const _nodes: ListData[] = [];\n\n      if (expandedValues.indexOf(treeOption.value) > -1) {\n        treeOption.children?.forEach((item) => {\n          _nodes.push({\n            ...item,\n            tier,\n          });\n\n          _nodes.push(...findVisibleItem(item, tier + 1));\n        });\n      }\n\n      return _nodes;\n    };\n\n    options.forEach((item) => {\n      nodes.push({\n        ...item,\n        tier: 0,\n      });\n\n      nodes.push(...findVisibleItem(item, 1));\n    });\n\n    return nodes;\n  }, [options, expandedValues]);\n\n  const SearchFlatListRef = useRef<FlatList>(null);\n  const [keyword, setKeyword] = useState('');\n  const searchListData = useMemo(() => {\n    const _onSearch = getOnSearch();\n    const _options = flattenDeepWidthChildren(options);\n    const _defaultFilter = () => {\n      const nodes: TreeSearchListData[] = [];\n\n      _options.forEach((item) => {\n        const _labels = buildHighlightLabelConfig(item.label, keyword);\n\n        if (_labels.length) {\n          // 找到父级数据\n          const parentNodes = findAllParentNodeByValue(options, item.value);\n\n          if (parentNodes?.length) {\n            _labels.push({\n              highlight: false,\n              text: ` / ${parentNodes.map((pn) => pn.label).join(' / ')}`,\n            });\n          }\n\n          nodes.push({\n            ...item,\n            labels: _labels,\n          });\n        }\n      });\n\n      return nodes;\n    };\n\n    return _onSearch ? _onSearch(keyword, _options) : _defaultFilter();\n  }, [keyword, getOnSearch, options]);\n\n  const _indent = getDefaultValue(indent, 24)!;\n  const flatListStyle = useMemo<ViewStyle>(() => {\n    if (minHeight === false) {\n      return {};\n    }\n\n    if (typeof minHeight === 'number') {\n      return {\n        minHeight,\n      };\n    }\n\n    return {\n      minHeight: 200,\n    };\n  }, [minHeight]);\n\n  const onSearchKeyword = usePersistFn((t) => {\n    setKeyword(t);\n    SearchFlatListRef.current?.scrollToIndex({\n      index: 0,\n    });\n  });\n  const genOnPressItem = (item: TreeOption) => () => {\n    if (multiple) {\n      const valueTarget = value as TreeValue[];\n      const _value = valueTarget.filter((v) => v !== item.value);\n      const isInValue = _value.length !== valueTarget.length;\n\n      const onChangeMultiple = (values: TreeValue[]) => {\n        onChange(\n          values,\n          values.map((v) => findNodeByValue(options, v)),\n          {\n            checked: !isInValue,\n            option: item,\n          }\n        );\n      };\n\n      if (TreeMultipleMode.INDEPENDENT === multipleMode) {\n        // 每个节点都是独立的\n        if (isInValue) {\n          onChangeMultiple(_value);\n        } else {\n          onChangeMultiple([..._value, item.value]);\n        }\n      } else {\n        /** 所有子节点+自身节点 */\n        const _nextValues = findAllChildrenValue(item.children || []);\n\n        _nextValues.push(item.value);\n\n        if (isInValue) {\n          // 找到所有父节点\n          // 追加当前及以后的节点\n          const _ps = findAllParentNodeByValue(options, item.value)\n            .map((p) => p.value)\n            .concat(_nextValues);\n\n          // 向上查找父节点\n          onChangeMultiple(_value.filter((v) => _ps.indexOf(v) === -1));\n        } else {\n          // 先追加自身和子节点\n          _nextValues.forEach((v) => {\n            if (_value.indexOf(v) === -1) {\n              _value.push(v);\n            }\n          });\n\n          /** 查看父节点是否要追加进去 */\n          const doPushParent = (subValue: TreeValue) => {\n            const _p = findParentNodeByValue(options, subValue);\n\n            if (_p) {\n              const _pNextValues = findAllChildrenValue(_p.children || []);\n\n              // 父节点的所有子节点是否都在 _value\n              if (_pNextValues.filter((pnv) => _value.indexOf(pnv) === -1).length === 0) {\n                _value.push(_p.value);\n                doPushParent(_p.value);\n              }\n            }\n          };\n\n          doPushParent(item.value);\n\n          onChangeMultiple(_value);\n        }\n      }\n    } else {\n      const _node = findNodeByValue(options, item.value);\n\n      if (item.value !== value) {\n        onChange(item.value, [_node], {\n          checked: true,\n          option: item,\n        });\n      } else {\n        if (cancellable) {\n          onChange(null, [], {\n            checked: false,\n            option: item,\n          });\n        }\n      }\n    }\n  };\n\n  return (\n    <>\n      {search ? <Search placeholder={placeholder} onSearch={onSearchKeyword} autoSearch /> : null}\n\n      {search && keyword ? (\n        searchListData.length ? (\n          <FlatList<TreeSearchListData>\n            key='search'\n            ref={SearchFlatListRef}\n            keyboardShouldPersistTaps='handled'\n            bouncesZoom={false}\n            contentContainerStyle={flatListStyle}\n            data={searchListData}\n            keyExtractor={(item) => `${item.value}`}\n            renderItem={({ item }) => {\n              const isActive = multiple\n                ? (value as TreeValue[]).indexOf(item.value) > -1\n                : value === item.value;\n\n              return (\n                <TreeItem\n                  onPress={genOnPressItem(item)}\n                  multiple={multiple}\n                  indent={_indent}\n                  bold={item.bold}\n                  disabled={!editable || !!item.disabled}\n                  tier={0}\n                  label={item.label}\n                  active={isActive}\n                  activeColor={item.activeColor ?? '#4080FF'}\n                  renderLabel={\n                    isActive\n                      ? undefined\n                      : (p: any) => {\n                          return (\n                            <Text\n                              className={cn('mx-1 flex-1 text-sm text-gray-800', {\n                                'text-gray-500': p.disabled,\n                                'text-primary': p.active || p.labelHighlight,\n                              })}\n                              numberOfLines={1}\n                            >\n                              {item.labels.map((tObj, index) => {\n                                if (tObj.highlight) {\n                                  return (\n                                    <Text key={index} className='text-primary'>\n                                      {tObj.text}\n                                    </Text>\n                                  );\n                                }\n\n                                return <React.Fragment key={index}>{tObj.text}</React.Fragment>;\n                              })}\n                            </Text>\n                          );\n                        }\n                  }\n                />\n              );\n            }}\n          />\n        ) : (\n          <View className='h-52'>\n            <Empty full />\n          </View>\n        )\n      ) : (\n        <FlatList\n          key='list'\n          bouncesZoom={false}\n          contentContainerStyle={flatListStyle}\n          data={listData}\n          ListEmptyComponent={<Empty />}\n          keyExtractor={(item) => `${item.value}`}\n          renderItem={({ item }) => {\n            const isActive = multiple\n              ? (value as TreeValue[]).indexOf(item.value) > -1\n              : value === item.value;\n            const _renderSwitcherIcon = item.renderSwitcherIcon || renderSwitcherIcon;\n            const _onPressSwitcherIcon = () => {\n              setExpandedValues((evs) => {\n                const _evs = evs.filter((v) => v !== item.value);\n\n                if (_evs.length !== evs.length) {\n                  return _evs;\n                }\n\n                return [..._evs, item.value];\n              });\n            };\n            const _switcherIcon = item.children?.length ? (\n              _renderSwitcherIcon ? (\n                _renderSwitcherIcon({\n                  color: '#4080FF',\n                  size: 16,\n                })\n              ) : (\n                <ArrowRightOutline color='#4080FF' size={16} />\n              )\n            ) : null;\n            const _switcherIconJSX =\n              expandedValues.indexOf(item.value) > -1 && item.switcherIconRotatable !== false ? (\n                <View style={switcherIconWrapperStyle}>{_switcherIcon}</View>\n              ) : (\n                _switcherIcon\n              );\n            const _labelHighlight =\n              findAllChildrenValue(item.children || []).filter((ic) => {\n                if (multiple) {\n                  return (value as TreeValue[]).indexOf(ic) > -1;\n                } else {\n                  return ic === value;\n                }\n              }).length > 0;\n\n            return (\n              <TreeItem\n                onPress={genOnPressItem(item)}\n                switcherIcon={_switcherIconJSX}\n                switcherHighlight={item.switcherHighlight}\n                multiple={multiple}\n                indent={_indent}\n                bold={item.bold}\n                disabled={!editable || !!item.disabled}\n                tier={item.tier}\n                label={item.label}\n                active={isActive}\n                renderLabel={item.render}\n                labelHighlight={_labelHighlight}\n                hasChildren={(item.children?.length || 0) > 0}\n                onPressSwitcherIcon={_onPressSwitcherIcon}\n                activeColor={item.activeColor ?? '#4080FF'}\n              />\n            );\n          }}\n        />\n      )}\n    </>\n  );\n};\n\nexport default Tree;\n",
      "type": "registry:component"
    }
  ]
}