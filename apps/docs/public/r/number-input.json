{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "number-input",
  "type": "registry:component",
  "title": "Example number-input",
  "author": "@gabimoncha",
  "description": "Displays a button which is always red.",
  "files": [
    {
      "path": "./node_modules/@rnr/example-library/src/components/number-input/index.tsx",
      "content": "import isNil from 'lodash/isNil';\nimport isUndefined from 'lodash/isUndefined';\nimport noop from 'lodash/noop';\nimport React, { useState, useCallback, useRef, memo, forwardRef } from 'react';\nimport { Platform } from 'react-native';\nimport type { NativeSyntheticEvent, TextInputEndEditingEventData } from 'react-native';\n\nimport TextInput from '../text-input';\nimport type { TextInputInstance } from '../text-input/interface';\n\nimport type { NumberInputProps } from './interface';\nimport { usePersistFn, useUpdateEffect } from '../../hooks';\nimport { formatDecimal, formatNumber } from '../../helpers';\n\nconst parserNumberToString = (n?: number | null) => `${!isNil(n) ? n : ''}`;\nconst defaultFormatter = (t: string) => t;\nconst defaultParser = (t: string) => Number(t);\n\n/**\n * 数字输入框\n * @description 输入中过滤所有非数字类字符，输入结束结合外界的 parser 修正数据\n */\nconst NumberInput = forwardRef<TextInputInstance, NumberInputProps>(\n  (\n    {\n      type = 'number',\n      min = Number.MIN_SAFE_INTEGER,\n      max = Number.MAX_SAFE_INTEGER,\n      formatter,\n      parser,\n      limitDecimals = -1,\n      validateTrigger = 'onEndEditing',\n\n      value,\n      defaultValue,\n      onEndEditing,\n      onChange,\n      ...restProps\n    },\n    ref\n  ) => {\n    if (isNil(restProps.keyboardType)) {\n      if (Platform.OS === 'ios') {\n        restProps.keyboardType = 'numbers-and-punctuation';\n      }\n      if (Platform.OS === 'android') {\n        restProps.keyboardType = 'decimal-pad';\n      }\n    }\n    if (type === 'digit') {\n      // restProps.keyboardType = 'number-pad'\n      limitDecimals = -1;\n    }\n\n    const onEndEditingPersistFn = usePersistFn(onEndEditing || noop);\n    const onChangePersistFn = usePersistFn(onChange || noop);\n    const parserPersistFn = usePersistFn(parser || defaultParser);\n    const formatterPersistFn = usePersistFn(formatter || defaultFormatter);\n\n    const [localValue, setLocalValue] = useState(\n      formatterPersistFn(parserNumberToString(!isUndefined(value) ? value : defaultValue))\n    );\n    /** 记录外部的数值 */\n    const LastValue = useRef<number | null | undefined>(!isUndefined(value) ? value : defaultValue);\n\n    // 同步数据\n    useUpdateEffect(() => {\n      // 输入 10.00001 删除最后一位，输入框期望保持 10.0000 字样\n      if (value !== LastValue.current) {\n        // 记录上次/当前外部的数字\n        LastValue.current = value;\n        // 更新内部的值\n        setLocalValue(formatterPersistFn(parserNumberToString(value)));\n      }\n    }, [value]);\n\n    /** 数据过滤，限制小数位，返回数字的字符串 */\n    const parserInputValue = usePersistFn((t: string) => formatDecimal(t, limitDecimals));\n\n    /** 计算数据 */\n    const computeValueStringify = useCallback(\n      (t: string, validate: boolean, isEnd: boolean) => {\n        // 部分数据开始格式化\n        // 允许输入正整数\n        const isNumber = type === 'number';\n        t = formatNumber(t, isNumber, true);\n\n        // 解析数据\n        let newValueStringify: string | null = parserInputValue(t);\n\n        if (newValueStringify !== '') {\n          if (validate) {\n            const newValueNum = Number(newValueStringify);\n            // 输入结束做最大、最小限制\n            if (newValueNum > max) {\n              newValueStringify = String(max);\n            }\n            if (newValueNum < min) {\n              newValueStringify = String(min);\n            }\n          }\n\n          // 结束的时候限制最大最小值\n          if (isEnd) {\n            if (t === '-') {\n              newValueStringify = null;\n            }\n          }\n        }\n\n        return newValueStringify;\n      },\n      [max, min, parserInputValue, type]\n    );\n\n    const triggerValueUpdate = useCallback(\n      (t: string, validate: boolean, isEnd: boolean) => {\n        // 输入 . 默认转换成 0.\n        if (t === '.') {\n          t = '0.';\n        }\n\n        // 当 min >= 0 就不能输入  -\n        if (min >= 0) {\n          t = t.replace(/-/g, '');\n        }\n\n        let newValueStringify = computeValueStringify(t || '', validate, isEnd);\n        let finallyValue = newValueStringify;\n\n        // 同步更新到组件状态\n        // 第一个字符串非数字，newValueStringify 是 null，setLocalValue(null) 不能触发更新，导致限制其他字符输入失败\n        setLocalValue(formatterPersistFn(newValueStringify!) || '');\n\n        // 1. 空字符串 + 非 null\n        // 2. 空字符串 + null\n        // 3. 非空字符串 + null\n        // 4. 非空字符串 + 非 null\n\n        if (newValueStringify === '' && LastValue.current !== null) {\n          // 状态 1 触发 onChange\n          onChangePersistFn(null);\n\n          finallyValue = null;\n          LastValue.current = null;\n        } else if (newValueStringify) {\n          // 状态 3 和 状态 4\n          if (isEnd) {\n            // 按照提供的解析函数转成数字\n            const returnValue = parserPersistFn(newValueStringify);\n            finallyValue = parserNumberToString(returnValue);\n\n            // 新数字转成字符串\n            setLocalValue(formatterPersistFn(finallyValue));\n\n            if (returnValue !== LastValue.current) {\n              // 当最终值和上次值不同时触发 onChange\n              onChangePersistFn(returnValue);\n              LastValue.current = returnValue;\n            }\n          } else {\n            // 聚焦输入中\n            // 字符串有数字\n            // 格式化后的值和最新值不相同\n            // '1.' 和 1 在 Number 后是一致的\n            // '1.0' 和 1 在 Number 后是一致的\n            const newValueNum = Number(newValueStringify);\n\n            if (\n              newValueStringify &&\n              newValueStringify !== '-' &&\n              newValueNum !== LastValue.current\n            ) {\n              onChangePersistFn(newValueNum);\n              LastValue.current = newValueNum;\n            }\n          }\n        }\n\n        return finallyValue;\n      },\n      [computeValueStringify, formatterPersistFn, min, onChangePersistFn, parserPersistFn]\n    );\n\n    const onChangeTextTextInput = useCallback(\n      (t: string) => {\n        triggerValueUpdate(t, validateTrigger === 'onChangeText', false);\n      },\n      [triggerValueUpdate, validateTrigger]\n    );\n\n    const onEndEditingTextInput = useCallback(\n      (e: NativeSyntheticEvent<TextInputEndEditingEventData>) => {\n        e.nativeEvent.text =\n          triggerValueUpdate(e.nativeEvent.text, validateTrigger === 'onEndEditing', true) || '';\n        onEndEditingPersistFn(e);\n      },\n      [onEndEditingPersistFn, triggerValueUpdate, validateTrigger]\n    );\n\n    return (\n      <TextInput\n        {...restProps}\n        ref={ref}\n        type='text'\n        value={localValue}\n        onChangeText={onChangeTextTextInput}\n        onEndEditing={onEndEditingTextInput}\n      />\n    );\n  }\n);\n\nexport default memo(NumberInput);\n",
      "type": "registry:component"
    }
  ]
}